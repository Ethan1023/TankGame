#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>
#include <SDL2/SDL_ttf.h>
#include <stdio.h>
#include <string>
#include <cmath>
#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>

/*GAME INFO:
	autosaving - lvl 1, save with heat going to 0 - lvl 2, save entering new room with no heat - lvl 3, save with no velocity and heat and frame%50=0
	can only use a teleporter if no heat
        reason - don't want the enemy to know you have access to teleporting
    materials are gained by touching dead enemies - two amounts, onperson, and safe. onperson is added to safe upon clearing heat, onperson is lost if killed.
*/

/*DOCUMENTATION:
	Ha good luck understanding anything
*/

/*TODO:
save and load these from the tank class:
timeSinceSeen
chaseTime
xPath
yPath
toprocess
patrolling

implement processing path and patrols

possibly add maxradius and outsiderectangle to shape - if outside one of those there is no collision
add in precalcs - memory usage of program is still very low, but cpu usage is a bit higher - complete static calculations beforehand
double check checkcollision running, see if there is any way to optimise
add in more timers to find what chews up what time

possibly only run enemy AI once every couple of frames

add semiautomatic weapons

add weapon levelling - spend materials to boost base stats significantly, same for other stats possibly (maybe with special item), or something else to make upgrades work past level 30

add in portal unlock cost and state, the state is saved and loaded with the id

when dead, pay materials to respawn or load previous save

disable projectile stepping while frozen
minimap, and fullscreen map

IDEAS:
    enemy AI only runs for enemies in the same room, but projectiles and traileffects run
    long range teleporters at end of each area - cost significant materials to unlock, plus possibly special items
    xp gained on death as "what not to do next time"
    respawning as person is free
    why can respawning happen (in game explanation):
        tank control is well protected, if tank is "killed", player simply teleports out, and enemies don't care cos they think you're dead
        after body is disposed of / people leave the area, you are teleported back to base and revived
    fix no response to exit signal

BUGS:
    crashes after loading game and then returning to menu and starting new game
	turning and moving at the same time - glitch into wall - maybe not too bad
	enemies stuck on corners - "OH FUCK"
	enemies dont go back through portals
	vector being called with index -1 (18446744073709551615)
*/

//{DECLARATIONS

double globaltemp;
int shapecollide;

//{timing
#include <chrono>
typedef std::chrono::high_resolution_clock Clock;
const bool timing = true;
std::vector<uint32_t> AIruntimes;
std::vector<uint32_t> otherruntimes;
std::vector<uint32_t> stepruntimes;
//}

//{CONSTANTS & VARIABLES
//constants
const int SCREEN_WIDTH = 1280;
const int SCREEN_HEIGHT = 960;
const double PI = 3.14159265358979323846;

//mouse and camera
int mouseX = 0;
int mouseY = 0;
int mouseXfreeze = 0;
int mouseYfreeze = 0;
double camX = 0;
double camY = 0;
bool LmouseState = 0;
bool LmouseClick = 0;
bool RmouseState = 0;
bool RmouseClick = 0;

//rendering
SDL_Window* gWindow;
SDL_Renderer* gRenderer = NULL;
TTF_Font *gFont = NULL;
int fontSize = 28;
double xzoom=1;//two variables makes it easier to have fun later on
double yzoom=1;

//game speed and framerate
double stepSize = 0.01; //speed of game - adjusted based on framerate
double TICKS_PER_FRAME;
double FPS = 60;
double slomospeed = 1;
double maxslomospeed = 16;
double slomo=100;
double slomoregen=1;
double slomousage=1;
double slomoresponse=1;
uint32_t frameCount = 0;
uint32_t lastpause;
uint32_t pauseduration;
bool recentpause = false;

//calculation performance
double scanangleincrement = 0.001; //increment when searching for a line of sight to a target, larger = lower vision precision, better performance
uint32_t precisevisionfrequency = 30; //how often precise vision is used in cansee for a much higher cpu cost - can be quite high as it realistically may take enemies a second to spot player if they can only see the very corner
//cansee costs 1/(precise*scan) = time cost ratio
double circleres = 8;  //number of points generated in a circular shape, higher = more accurate collision detection, lower performance

//graphics
double traileffectprescision = 15;
uint32_t effectIDs = 0;

//menu and keys
bool pause = false;
bool menu = false;
const Uint8* keys = SDL_GetKeyboardState( NULL );

//game
bool freeze = false;
bool aiminglaser = true;
bool heat = false;
double heatnum = 0;
int maxrepairs=5;//reset from character file
const int pointsperlevel=5;//constant

//cheats
bool theflash=false;

//saving
uint8_t saved=0;
uint32_t savetime=0;

//AI
bool processingAvailable=true;

//other
bool showSecondary = false;//display secondary weapon stats in quick menu

//settings
double MAX_FPS = 60;    //maximum framerate
bool particleEffects = false;
double streakrenderres = 0.01;  //how accurately the streak left behind a projectile will be rendered close to a hit target - smaller = more accurate
int physics = 3;	//physics loops per graphical loop
double mul = 2;     //scale of tanks and projectiles physical sizes
double gamespeed = 2;   //actual speed of game
double firstup=1.1;//potency of first upgrade
double deterioration=0.9;//deterioration of each sequential upgrade
int savelevel=2;

//bool damagefx = false;
//{controls:
SDL_Scancode fowardsKey = SDL_SCANCODE_W;
SDL_Scancode backwardsKey = SDL_SCANCODE_S;
SDL_Scancode leftKey = SDL_SCANCODE_A;
SDL_Scancode rightKey = SDL_SCANCODE_D;
SDL_Scancode brakeKey = SDL_SCANCODE_SPACE;
SDL_Scancode slomoKey = SDL_SCANCODE_LSHIFT;
SDL_Scancode quickMenuKey = SDL_SCANCODE_LCTRL;
SDL_Scancode pauseKey = SDL_SCANCODE_ESCAPE;
SDL_Scancode menuKey = SDL_SCANCODE_TAB;
SDL_Scancode primaryWeaponAssistKey = SDL_SCANCODE_LALT;
SDL_Scancode portalKey = SDL_SCANCODE_F;
SDL_Scancode zoomKey = SDL_SCANCODE_GRAVE;
bool primaryWeaponAssistKeyState = false;
bool primaryWeaponAssistToggle = false;

bool portalKeyState = false;
bool portalKeyPress = false;
//}

//}

//{STRUCTS
struct PercentRect{ //used for clipping images
	double x;
	double y;
	double w;
	double h;
};

struct ParticleLine{
    double x1;
    double y1;
    double x2;
    double y2;
    double r = 0xFF;
    double g = 0;
    double b = 0;
    double a = 0xFF;
    double t = 0;
    double dr = 0;
    double dg = 0;
    double db = 0;
    double da = -0.05;
    double dt = 0.05;
    uint32_t id=0;
    uint16_t room=0;
};

struct Projectile{
	uint16_t room=0;
    double x;
    double y;
    double xvel;
    double yvel;
    double angle;               //Angle of projectile in degrees
    int width;
    int length;
    SDL_Texture* look;          //visual look of projectile
    SDL_Rect* clip;              //clip of look to be rendered
    double damage;
    double range=0;
    bool passesShield=false;
    ParticleLine* traileffect;

	double totaldist=0;//total distance
    int dist=0;//steps travelled on current trail effect segment
    uint32_t lastid=0;

    int ownerID;
    bool primaryWeapon;
};

struct Shape{
    std::vector<double> x;
    std::vector<double> y;
    bool isRectangle=false;
    uint16_t room=0;
    std::vector<double> prevangle;
    std::vector<double> nextangle;
};

struct Weapon{
    std::string name;
    uint32_t ID;
    double speed;
    uint32_t range;
    int ROF;
    double spread;
    int burst;
    double damage;
    bool passesshields;
    double energy;
    bool primary;
    uint32_t cost;
};

struct WeaponUpgrades{//each upgrade increases value as described in struct Character, if value is an int round down to nearest worst whole value
	int ID;
	int points;
	int speed=0;
	int ROF=0;
	int spread=0;
	int burst=0;
	int damage=0;
	int energy=0;
	int range=0;
};

struct Character{
	std::string name;
	uint32_t materials;
	uint32_t safematerials;
	uint32_t exp;//store exp, every level needs 1000 exp, but enemies give lower rewards the more exp you have
	int repairs;

	double power;
	double brake;
	double maxVelocity;
	double mass;
	double energy;
	double generation;
	double health;
	double shield;
	double regen;
	double delay;
	double slomomax;
	double slomoregen;
	double slomousage;
	double slomoresponse;
	int maxrepairs;

	int powerup;//power = power*for(i in powerup) 1.1^(0.9^i)...powerup=3, power=power*1.1*1.1^0.9*(1.1^0.9)^0.9
	int brakeup;//primitive, but causes upgrades to gradually become less effective so other upgrades become more worthwhile
	int maxVelocityup;
	int massdown;
	int energyup;
	int generationup;
	int healthup;
	int shieldup;
	int regenup;
	int delayup;
	int slomomaxup;
	int slomoregenup;
	int slomousageup;
	int slomoresponseup;
	int maxrepairsup;

	int upgradepoints;
	int totalweaponpoints;
	std::vector<int> weapons;//contains IDs
	std::vector<WeaponUpgrades> weaponUpgrades;
	int primaryID;
	int secondaryID;
};

struct Portal{
	int room;
	int x;
	int y;
	int w;
	int h;
	uint32_t id;
	uint32_t toid;
	bool inwall;
};

struct RoomDimension{
	int mapwidth;
	int mapheight;
	int room;
};
//}

//{ENUMERATIONS
enum command { ACCELERATE, BRAKE, TURN, TURNTURRET, BRAKETURRET };
//}

//{CLASSES
class Tank{
	public:
        Tank();
		Tank(std::string, double, double, double, uint16_t);
		void positionReset(std::string, double, double, double, uint16_t, bool);
		~Tank();
		void step();
		void patrol();
		void render();
		void free();
		void loadLook0();
		void loadLook(std::string, std::string, std::string, std::string, std::string, PercentRect*, PercentRect*, PercentRect*, PercentRect*, PercentRect*, SDL_Rect*, SDL_Rect*, SDL_Rect*, SDL_Rect*, SDL_Rect*);
		void setDimensions(double, double, double, double, double, double, double, double, double);
		void setOther(int, double, double, double, double, double, double, uint32_t, uint32_t);
		void setWeapons(double, double, double, double, int, int, double, double, int, int, ParticleLine, ParticleLine, bool, bool, double, double);
		bool primaryReloaded();
		bool secondaryReloaded();
		void setHealth(double, double, double, int);
		uint32_t takeDamage(double, bool);
		bool isDead();
		double getLength();
		int getID();
		uint32_t getexp();
		uint32_t getmaterials();
		void strip();
		bool isStripped();
		double getViewDistance(bool);
		void broadcast();
		void boostView();
				//commands
        void settargetvel(double);
        void pointTo(double, double);
        void shootPrimary(Projectile*);
        void shootSecondary(Projectile*);
        void accelerate(double);	//accelerate with power
		void brake(double);		//brake with force
		void turn(double);		//set power distribution between tracks (to steer)
				//accessors
		double getShieldTimer();
		double getShieldDelay();
        bool hasseentarget();
        void getTarget(double**, double**);
        double getHealth();
        double getMaxHealth();
        double getShield();
        double getMaxShield();
        double getShieldRegen();
		double getX();			//get x position
		double getY();			//get y position
		double getOldX();
		double getOldY();
		int getCurrentRoom();
		double getXvel();
		double getYvel();
		double getVel();
		double getRot();		//get rotation of tank
		double getTurretrot();		//get rotation of turret
		int getPburst();    //projectiles fired per shot
		int getSburst();
		std::string getName();
		void setName(std::string);
		int getIndex();
		void setIndex(int);
		Shape getShape();
		void setIsCircle(bool);
		bool isACircle();
		int getPrimaryROF();     //reload time in game steps
		int getSecondaryROF();
		double getPrimaryReload();  //time spent reloading
		double getSecondaryReload();
		double getPrimaryDamage();
		double getSecondaryDamage();
		double getPspread();
		double getSspread();
		double getMaxVel();
		double getAcceleration();
		bool getpPassesShield();
		bool getsPassesShield();
		double getEnergy();
		double getMaxEnergy();
		double getEnergyGen();
		double getPEnergy();
		double getSEnergy();
		void getProjectileLook(SDL_Texture**, SDL_Rect**, ParticleLine**, bool);
		//saving
		void save(std::ofstream*);
		void load(std::ifstream*);
		void loadfromcharacter();
		//AI
		void resetTimeSinceSeen();
		void incrementTimeSinceSeen(double);
	private:
				//graphics
		SDL_Texture* body;		//image of tank body
		SDL_Rect bodyclip;		//clip of body image file
		SDL_Texture* turret;		//image of turret
		SDL_Rect turretclip;		//clip of turret image file
		SDL_Texture* barrel;		//image of barrel
		SDL_Rect barrelclip;		//clip of barrel
		SDL_Texture* pproj;      //image of primary projectile
		SDL_Rect pprojclip;      //clip of primary projectile
		SDL_Texture* sproj;      //image of secondary projectile
		SDL_Rect sprojclip;      //clip of secondary projectile
				//position
		uint8_t stuckness=0; //value to track how long stuck for
		double x;			//x position
		double y;			//y position
		double oldx;
		double oldy;
		double xvel;			//x velocity
		double yvel;			//y velocity
		double vel;             //velocity
		double tankrot;			//rotation of tank
		uint16_t currentRoom;
		uint32_t markedPortal;
		double turretrot;		//rotation of turret relative to tank
		double targetX = -1000;
		double targetY = -1000;
		Shape shape;
		double targetvel;
				//specs
					//mass
		double mass;			//mass of tank body
					//size
        bool iscircle = false;
		double length;			//length of body
		double width;			//width of body
		//double trackwidth;		//width of tracks
		double turretradius;		//radius of turret
		double barrellength;		//length of barrel
		double barrelwidth;		//width of barrel
		double pprojlength;
		double pprojwidth;
		double sprojlength;
		double sprojwidth;
					//other
		double power;			//power of engine (continous gearing is used)
		double brakeforce;		//force of brakes
		double maxvel;          //maximum velocity
		double energy;
		double maxEnergy;
		double energyGen;
                    //weapons
        double primaryDamage;
        double secondaryDamage;
        uint32_t primaryRange;
        uint32_t secondaryRange;
		double primaryProjectileSpeed;
		double secondaryProjectileSpeed;
		int primaryROF;     //reload time in game steps
		int secondaryROF;
		double primaryReload;  //time spent reloading
		double secondaryReload;
		double pspread;
		double sspread;
		int pburst;
		int sburst;
		ParticleLine Peffect;
		ParticleLine Seffect;
		bool pPassesShield=false;
		bool sPassesShield=false;
        double pEnergy;
        double sEnergy;

        //health
        double maxHealth;
        double maxShield;
        double shieldRegen;
        double shieldDelay;
        double health;
        double shield;
        double shieldCount=0;
        bool dead=false;
        bool stripped=false;//has player scavenged materials(increases respawn time)

        //AI
        double viewDistance=500;
        double boostedViewDistance=500;
        double broadcastDistance=500;
        double chaseTime=10;
		double timeSinceSeen=chaseTime;
		std::vector<double> xPath;
		std::vector<double> yPath;
		bool toprocess=false;
		bool patrolling=true;

        uint32_t expgiven=0;
        uint32_t materialsgiven=0;

        int ID; //ID assigned in tanktemplates file
        int index;  //index of tank in
        std::string name;
		double commands [5] = {0, 0, 0, 0, 0};		//array containing values of commands passed to tank
};
//}

//{METHODS
void init();
void loadMedia();
bool loadSettings(char*);
void loadTankTemplates(char*);
void loadTanks(char*);
Character loadCharacter(char*);
Character updateCharacter(char*, Character);
std::vector<Weapon> loadWeapons(char*);
void setMap(char*);
void loadMap(std::vector<Shape*>*, char*);
uint8_t mainMenu();
uint8_t gameMenu();
uint8_t selectWeaponMenu(Character*);
uint8_t upgradeWeaponMenu(WeaponUpgrades*, uint32_t*, Character*);
void reloadCharacter();
void addButton(std::vector<Shape*>*, double, double, double, double);
uint8_t runGame(std::string*);
void save(std::string*);
void close();
bool updateMouse(bool capzoom=false);
void handleInput(Tank*);	//Reads keyboard input, and sends controls to the Tank passed in
bool stepProjectile(Projectile*);
bool cansee(int, int, double*, double*);
bool process(std::vector<double>*, std::vector<double>*);
double yfromx(double, double, double, double, double);
void fire(bool, bool, Tank*, std::vector<Projectile*>*);
Portal portalEnter(int);
char sideof(Portal);
Shape portalToShape(Portal);
RoomDimension getRoomDimension(int);
bool collision(int);
bool passedovershape(double, double, double, double, Shape);
bool passedover(double, double, double, double, double, double, double, double);
void sortpoints(std::vector<double>*, std::vector<double>*);
bool isInShape(double, double, Shape);
void preLoadAngles(Shape*);
double atan2(double, double, double, double);
bool checkcollision(Shape, Shape);//, double*, bool*);
bool checkcollision(Shape, Shape, double, double);
double findCollisionAngle(double, double, double, double, Shape);
int findSide(double, double, Shape);
double nearestpoint(double, double, double, double, double, double);
double distanceto(double, double, double, int, double, double);
void impactcoords(double, double, double, int, double, double, double*, double*);
double xToDispX(double);
double yToDispY(double);
int SCROLL_RenderDrawLine(SDL_Renderer*, int, int, int, int);
uint8_t pauseMenu(std::string*);
void saveMenu(std::string*);
std::string loadMenu();
void basicText(std::string, SDL_Color, int, int, double, double, bool, uint8_t, uint8_t, uint8_t, uint8_t);
void verybasicText(std::string, int, int, double);

void saveParticleLine(ParticleLine, std::ofstream*);
ParticleLine loadParticleLine(std::ifstream*);
void saveShape(Shape, std::ofstream*);
Shape loadShape(std::ifstream*);
void saveProjectile(Projectile, std::ofstream*);
Projectile loadProjectile(std::ifstream*);
void saveTank(Tank, std::ofstream*);
Tank loadTank(std::ifstream*);
void saveWeapon(Weapon, std::ofstream*);
Weapon loadWeapon(std::ifstream*);
void saveCharacter(Character, std::ofstream*);
Character loadCharacter(std::ifstream*);
void saveWeaponUpgrades(WeaponUpgrades, std::ofstream*);
WeaponUpgrades loadWeaponUpgrades(std::ifstream*);
void saveStatus(std::ofstream*);
void loadStatus(std::ifstream*);

//}

//{CONSTANTS AND VARIABLES RELYING ON THE ABOVE
Tank* showDetailsFor = NULL;
std::vector<Tank*> tanks;
std::vector<Tank> tankTemplates;
std::vector<Shape*> shapes;
std::vector<ParticleLine> particlelines;
Character character;
std::vector<Weapon> weapons;
std::vector<Portal> portals;
std::vector<RoomDimension> roomDimensions;
std::vector<Projectile*> projectiles;
//}

//}

//{DEFINITIONS

//{TANK

void Tank::step(){
	std::cout << timeSinceSeen << "\n";
	auto t1step = Clock::now();
	oldx=x;
	oldy=y;
	if(theflash && index==0)
		stepSize*=slomospeed;
	if(!dead){
    if(index!=0){
		if(vel<5 && primaryReloaded() && secondaryReloaded())
			health+=0.000001*(maxHealth-health)*300*stepSize*300/physics;
        double dist = sqrt((targetX-x)*(targetX-x) + (targetY-y)*(targetY-y));
        if(targetvel==0){
            if(dist < length/2 && vel > targetvel && toprocess){
                vel = 0;
                commands[BRAKE] = 0;
                commands[ACCELERATE] = 0;
            }
        }else{
            if(dist < (length/2+50)){// && vel > targetvel){
                commands[BRAKE] = 100;
                commands[ACCELERATE] = 0;
            }
        }
		if((targetX!=-1000 || targetY!=-1000)&&!patrolling){
			if((frameCount+index)%100==0){
				xPath.push_back(x);
				yPath.push_back(y);
				toprocess=true;
			}
        }
    }else{//health regen for player - occurs with no heat, full energy and almost complete stop
		if(heatnum==0){
			character.safematerials+=character.materials;
			character.materials=0;
			if(energy==maxEnergy && vel<5 && health<maxHealth)
				health+=0.000001*(maxHealth-health)*(maxHealth-health)*stepSize*300/physics;
		}
		if(health>maxHealth)
			health==maxHealth;
    }
    if(primaryReload<primaryROF-30*200.0*stepSize*3/physics)
        primaryReload+=30*200.0*stepSize*3/physics;
	else
		primaryReload=primaryROF;
    if(secondaryReload<secondaryROF-30*200.0*stepSize*3/physics)
        secondaryReload+=30*200.0*stepSize*3/physics;
	else
		secondaryReload=secondaryROF;
    if(shieldCount<=shieldDelay)
        shieldCount+=stepSize*3/physics;
    if(shieldCount>=shieldDelay){
		shieldCount=shieldDelay;
        shield+=shieldRegen*stepSize*3/physics;
	}
    if(shield>maxShield)
        shield=maxShield;
    if(energy<maxEnergy)
        energy+=energyGen*stepSize*3/physics;
    else
        energy=maxEnergy;
	if(targetX!=-1000 || targetY!=-1000){
    if(index!=0){
        tankrot = (atan((targetY - y)/(targetX - x))*180/PI);
        targetX < x ? tankrot += 180 : tankrot;
    }
    turretrot = (atan((targetY - y)/(targetX - x))*180/PI) - tankrot;
    targetX >= x ? turretrot += 180 : turretrot;
	}
	}
  if(stuckness<100 || rand()%100){
	if(!dead || (index==0 && health>=0)){
	tankrot += commands[TURN] * stepSize * sqrt(fabs(vel)+1) / 10;//try turning
	if(collision(index)){
        tankrot -= commands[TURN] * stepSize * sqrt(abs(vel)+1) / 10;
        //std::cout << "Collision Detected...\n";
	}
	}
	tankrot > 360 ? tankrot -= 360 : (tankrot < 0 ? tankrot += 360 : tankrot = tankrot);
	double tankrotrad = (tankrot) * PI / 180;    //convert from visual rotation to rotation for calculation
	double usedpower = commands[ACCELERATE] * power / 100;  //calculate power used
	double drag = vel * vel / 10;   //drag so that tank can coast to a stop
	double braking = commands[BRAKE] * brakeforce / 100 + 10 + drag;   //strength of brakes being applied
	if(dead){
		usedpower=0;
		braking=10+drag;
	}
	double thrust = usedpower / ( abs(vel) + 0.1 );	//calculate thrust at current velocity
	if(thrust>0)
		thrust > usedpower/10 ? thrust = usedpower/10 : thrust = thrust;
	else
		thrust < usedpower/10 ? thrust = usedpower/10 : thrust = thrust;
	double dvel;
											//calculate acceleration provided to tracks by engine and brakes
	if( abs( thrust ) > braking ){							//tracks are powered by the engine
		vel > 0 ? thrust -= braking : thrust += braking;			//calculate net thrust
		dvel = stepSize * thrust / mass;				//calculate acceleration
	}else{										//tracks are braking
		thrust = braking - abs(thrust);						//calculate net braking
		vel > 0 ? dvel = -1 * stepSize * thrust / mass : dvel = stepSize * thrust / mass;				//calculate acceleration
		if(fabs(dvel)>fabs(vel)){
			dvel=0;
			vel=0;
		}
	}
    vel += dvel;
    if(vel > maxvel)
        vel = maxvel;
    else if(fabs(vel) > maxvel)
        vel = -maxvel;
    xvel = cos(tankrotrad)*vel;
    yvel = sin(tankrotrad)*vel;
    x+=stepSize*xvel;//try moving, in the event of a collision, try moving at an angle to the rotation and add friction if not a circle
    y+=stepSize*yvel;
if(timing){
auto t2 = Clock::now();
otherruntimes.push_back(std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1step).count());
if(otherruntimes.size()>100)
otherruntimes.erase(otherruntimes.begin()+0);
}
    if(collision(index)){
            y-=stepSize*yvel;
            x-=stepSize*xvel;
		double firstx=x;
		double firsty=y;
		int32_t circle=std::round(PI*1000000*2);
		int32_t op1=(int32_t)(std::round((globaltemp+PI/2.0-tankrotrad)*1000000)+circle/2)%circle-circle/2;
		int32_t op2=(int32_t)(std::round((globaltemp+PI/2.0+PI-tankrotrad)*1000000)+circle/2)%circle-circle/2;
		if(abs(op1)<abs(op2)){
			x+=stepSize*cos(globaltemp+PI/2.0)*(vel);
			y+=stepSize*sin(globaltemp+PI/2.0)*(vel);
		}else{
			x-=stepSize*cos(globaltemp+PI/2.0)*(vel);
			y-=stepSize*sin(globaltemp+PI/2.0)*(vel);
		}

		if(collision(index)){
			x=firstx;
			y=firsty;
			vel/=2;
			if(index!=0 && stuckness<100){
				stuckness++;
			}
		}else{
			stuckness=0;
			if(!iscircle || usedpower==0){
				if(abs(op1)<abs(op2)){
					vel*=pow(fabs(cos((double)op1/1000000.0)), 0.5);//wall drag - based on cosine of difference between forwards and wall
				}else{
					vel*=pow(fabs(cos((double)op2/1000000.0)), 0.5);
				}
			}
		}
/*legacy collision detection (brute force tactic)
		bool solved=false;
		bool maxangle=PI/2.0;
        for(double i=tankrotrad-globaltemp-0.1; i<maxangle; i+=0.1){//i=0.1
            x+=stepSize*cos(tankrotrad+i)*vel;
            y+=stepSize*sin(tankrotrad+i)*vel;
            if(collision(index)){
                x-=stepSize*cos(tankrotrad+i)*vel;
                y-=stepSize*sin(tankrotrad+i)*vel;
                x+=stepSize*cos(tankrotrad-i)*vel;
                y+=stepSize*sin(tankrotrad-i)*vel;
                if(collision(index)){
                    x-=stepSize*cos(tankrotrad-i)*vel;
                    y-=stepSize*sin(tankrotrad-i)*vel;
                }else{
                    solved = true;
                    x-=stepSize*cos(tankrotrad-i)*vel*(1-cos(i))*(1-cos(i));
                    y-=stepSize*sin(tankrotrad-i)*vel*(1-cos(i))*(1-cos(i));
                    if(collision(index)){
                        x+=stepSize*cos(tankrotrad-i)*vel*(1-cos(i))*(1-cos(i));
                        y+=stepSize*sin(tankrotrad-i)*vel*(1-cos(i))*(1-cos(i));
                    }
                    if(!iscircle)
                        vel*=sqrt(fabs(cos(i)));
					else if(usedpower==0)
						vel*=sqrt(sqrt(fabs(cos(i))));
//					std::cout << "Long: " << tankrotrad-i << "\n";
                    i=PI;
                }
            }else{
                solved = true;
                x-=stepSize*cos(tankrotrad+i)*vel*(1-cos(i))*(1-cos(i));
                y-=stepSize*sin(tankrotrad+i)*vel*(1-cos(i))*(1-cos(i));
                if(collision(index)){
                    x+=stepSize*cos(tankrotrad+i)*vel*(1-cos(i))*(1-cos(i));
                    y+=stepSize*sin(tankrotrad+i)*vel*(1-cos(i))*(1-cos(i));
                }
                if(!iscircle)
                    vel*=sqrt(fabs(cos(i)));
//				std::cout << "Long: " << tankrotrad+i << "\n";
                i=PI;
            }
        }*/
	}
	if(portalEnter(index).id!=0){//check if colliding with exit portal
		Portal exitPortal = portalEnter(index);
		if(exitPortal.inwall){
			markedPortal = exitPortal.id;
		}else if (portalKeyPress && heatnum==0 && index==0 && !dead){
			if(savelevel>=2 && (savetime==0 || (SDL_GetTicks()+500)<savetime)){
				savetime=SDL_GetTicks()+500;
			}
			uint32_t toid = exitPortal.toid;
			for(int i=0;i<portals.size();i++){
				if(portals[i].id==toid)
					exitPortal=portals[i];
			}
			currentRoom = exitPortal.room;
			x=exitPortal.x+exitPortal.w/2;
			y=exitPortal.y+exitPortal.h/2;
		}
	}
	if(y<-100 || y>getRoomDimension(currentRoom).mapheight+100 || x<-100 || x>getRoomDimension(currentRoom).mapwidth+100){
		Portal entryPortal = portals[0];
		for(int i=0;i<portals.size();i++){
			if(portals[i].id==markedPortal)
				entryPortal=portals[i];
		}
		Portal exitPortal = portals[0];
		for(int i=0;i<portals.size();i++){
			if(portals[i].id==entryPortal.toid)
				exitPortal=portals[i];
		}
		currentRoom = exitPortal.room;
		switch (sideof(entryPortal)){
			case 'n':
				switch (sideof(exitPortal)){
					case 'n':
						x=exitPortal.x+exitPortal.w-exitPortal.w*(x-entryPortal.x)/(entryPortal.w);
						y=-100;
                        tankrot+=180;
					break;
					case 'e':
						y=exitPortal.y+exitPortal.h-exitPortal.h*(x-entryPortal.x)/(entryPortal.w);
						x=getRoomDimension(currentRoom).mapwidth+100;
						tankrot-=90;
					break;
					case 's':
						x=exitPortal.x+exitPortal.w*(x-entryPortal.x)/(entryPortal.w);
						y=getRoomDimension(currentRoom).mapheight+100;
					break;
					case 'w':
						y=exitPortal.y+exitPortal.h*(x-entryPortal.x)/(entryPortal.w);
						x=-100;
						tankrot+=90;
					break;
					default:
						x=exitPortal.x+exitPortal.w/2;
						y=exitPortal.y+exitPortal.h/2;
						if(y<-100)
							y=-100;
						else if(y>getRoomDimension(currentRoom).mapheight+100)
							y=getRoomDimension(currentRoom).mapheight+100;
						if(x<-100)
							x=100;
						else if(x>getRoomDimension(currentRoom).mapwidth+100)
							x=getRoomDimension(currentRoom).mapwidth+100;
					break;
				}
			break;
			case 'e':
				switch (sideof(exitPortal)){
					case 'n':
						x=exitPortal.x+exitPortal.w-exitPortal.w*(y-entryPortal.y)/(entryPortal.h);
						y=-100;
						tankrot+=90;
					break;
					case 'e':
						y=exitPortal.y+exitPortal.h-exitPortal.h*(y-entryPortal.y)/(entryPortal.h);
						x=getRoomDimension(currentRoom).mapwidth+100;
						tankrot+=180;
					break;
					case 's':
						x=exitPortal.x+exitPortal.w*(y-entryPortal.y)/(entryPortal.h);
						y=getRoomDimension(currentRoom).mapheight+100;
						tankrot-=90;
					break;
					case 'w':
						y=exitPortal.y+exitPortal.h*(y-entryPortal.y)/(entryPortal.h);
						x=-100;
					break;
					default:
						x=exitPortal.x+exitPortal.w/2;
						y=exitPortal.y+exitPortal.h/2;
						if(y<-100)
							y=-100;
						else if(y>getRoomDimension(currentRoom).mapheight+100)
							y=getRoomDimension(currentRoom).mapheight+100;
						if(x<-100)
							x=100;
						else if(x>getRoomDimension(currentRoom).mapwidth+100)
							x=getRoomDimension(currentRoom).mapwidth+100;
					break;
				}
			break;
			case 's':
				switch (sideof(exitPortal)){
					case 'n':
						x=exitPortal.x+exitPortal.w*(x-entryPortal.x)/(entryPortal.w);
						y=-100;
					break;
					case 'e':
						y=exitPortal.y+exitPortal.h*(x-entryPortal.x)/(entryPortal.w);
						x=getRoomDimension(currentRoom).mapwidth+100;
						tankrot+=90;
					break;
					case 's':
						x=exitPortal.x+exitPortal.w-exitPortal.w*(x-entryPortal.x)/(entryPortal.w);
						y=getRoomDimension(currentRoom).mapheight+100;
						tankrot+=180;
					break;
					case 'w':
						y=exitPortal.y+exitPortal.h-exitPortal.h*(x-entryPortal.x)/(entryPortal.w);
						x=-100;
						tankrot-=90;
					break;
					default:
						x=exitPortal.x+exitPortal.w/2;
						y=exitPortal.y+exitPortal.h/2;
						if(y<-100)
							y=-100;
						else if(y>getRoomDimension(currentRoom).mapheight+100)
							y=getRoomDimension(currentRoom).mapheight+100;
						if(x<-100)
							x=100;
						else if(x>getRoomDimension(currentRoom).mapwidth+100)
							x=getRoomDimension(currentRoom).mapwidth+100;
					break;
				}
			break;
			case 'w':
				switch (sideof(exitPortal)){
					case 'n':
						x=exitPortal.x+exitPortal.w*(y-entryPortal.y)/(entryPortal.h);
						y=-100;
						tankrot-=90;
					break;
					case 'e':
						y=exitPortal.y+exitPortal.h*(y-entryPortal.y)/(entryPortal.h);
						x=getRoomDimension(currentRoom).mapwidth+100;
					break;
					case 's':
						x=exitPortal.x+exitPortal.w-exitPortal.w*(y-entryPortal.y)/(entryPortal.h);
						y=getRoomDimension(currentRoom).mapheight+100;
						tankrot+=90;
					break;
					case 'w':
						y=exitPortal.y+exitPortal.h-exitPortal.h*(y-entryPortal.y)/(entryPortal.h);
						x=-100;
						tankrot+=180;
					break;
					default:
						x=exitPortal.x+exitPortal.w/2;
						y=exitPortal.y+exitPortal.h/2;
						if(y<-100)
							y=-100;
						else if(y>getRoomDimension(currentRoom).mapheight+100)
							y=getRoomDimension(currentRoom).mapheight+100;
						if(x<-100)
							x=100;
						else if(x>getRoomDimension(currentRoom).mapwidth+100)
							x=getRoomDimension(currentRoom).mapwidth+100;
					break;
				}
			break;
			default:
			x=exitPortal.x+exitPortal.w/2;
			y=exitPortal.y+exitPortal.h/2;
			if(y<-100)
				y=-100;
			else if(y>getRoomDimension(currentRoom).mapheight+100)
				y=getRoomDimension(currentRoom).mapheight+100;
			if(x<-100)
				x=100;
			else if(x>getRoomDimension(currentRoom).mapwidth+100)
				x=getRoomDimension(currentRoom).mapwidth+100;
		}
		if(index!=0){
			if(x<0){
				targetX=50;
				targetY=y;
			}else if(x>getRoomDimension(currentRoom).mapwidth){
				targetX=getRoomDimension(currentRoom).mapwidth-50;
				targetY=y;
			}else if(y<0){
				targetY=50;
				targetX=x;
			}else if(y>getRoomDimension(currentRoom).mapheight){
				targetY=getRoomDimension(currentRoom).mapheight-50;
				targetX=x;
			}
		}else if(heatnum==0){
			if(savelevel>=2 && (savetime==0 || (SDL_GetTicks()+500)<savetime)){
				savetime=SDL_GetTicks()+500;
			}
		}
	}
  }
	if(dead){
		if(health>=maxHealth){
			dead=false;
			stripped=false;
			health=maxHealth;
		}else if(health>=0){
			if(index==0)
				health+=(stepSize/physics)*maxHealth/5;
			else if(stripped)
				health+=stepSize/physics*maxHealth/100;
			else
				health+=stepSize/physics*maxHealth/30;
		}
	}

	if(theflash && index==0)
		stepSize/=slomospeed;
	if(collision(index)){//automatically undo any remnant collision, causes infinite loop if no space for tank in room
		double i=1;
		while(i!=0){
			for(double j=0;j<2*PI;j+=0.1){
				x+=cos(j)*i;
				y+=sin(j)*i;
				if(collision(index) || x<-100 || x>roomDimensions[currentRoom].mapwidth+100 || y<-100 || y>roomDimensions[currentRoom].mapheight+100){
					x-=cos(j)*i;
					y-=cos(j)*i;
				}else{
					i=0;
					j=2*PI;
				}
			}
			i*=1.5;
		}
    }
    if(timing){
		auto t2step = Clock::now();
		stepruntimes.push_back(std::chrono::duration_cast<std::chrono::nanoseconds>(t2step - t1step).count());
		if(stepruntimes.size()>100)
			stepruntimes.erase(stepruntimes.begin()+0);
	}
}

void Tank::patrol(){
	if(xPath.size()==0){
		brake(100);
		accelerate(100);
		//normal patrol
	} else if(toprocess && !process(&xPath, &yPath)){
		brake(100);
		accelerate(0);
	} else {
		toprocess=false;
		brake(0);
        accelerate(100);
        targetX=xPath[xPath.size()-1];
		targetY=yPath[yPath.size()-1];
        while(xPath.size()>0 && fabs(x-xPath[xPath.size()-1])<5 && fabs(y-yPath[yPath.size()-1])<5){
			xPath.erase(xPath.begin()+xPath.size()-1);
			yPath.erase(yPath.begin()+yPath.size()-1);
        }
	}
}

void Tank::pointTo(double targx, double targy){
    targetX = targx;
    targetY = targy;
}

void Tank::shootPrimary(Projectile* p){
    primaryReload = 0;
    energy-=pEnergy;
    if(energy<0)
        energy=0;
    p->x = x-cos((tankrot+turretrot)*PI/180)*(turretradius + barrellength);
    p->y = y-sin((tankrot+turretrot)*PI/180)*(turretradius + barrellength);
    p->angle = turretrot+tankrot;
    if(pspread>0)
		if(rand()%2 == 0)
			p->angle += pow(((rand()%100)*1.0), 4)/(200000000.0)*pspread;
		else
			p->angle -= pow(((rand()%100)*1.0), 4)/(200000000.0)*pspread;
	double tmp = 0.8+(rand()%401)/1000.0;
    p->xvel = xvel-cos(p->angle*PI/180)*primaryProjectileSpeed*tmp;
    p->yvel = yvel-sin(p->angle*PI/180)*primaryProjectileSpeed*tmp;
    p->width = pprojwidth;
    p->length = pprojlength;
    p->look = pproj;
    p->clip = &pprojclip;

    p->traileffect = &Peffect;
    p->damage = primaryDamage;
    p->range = primaryRange*(0.9+(rand()%201)/1000.0);
    p->passesShield = pPassesShield;

    p->ownerID=ID;
    p->primaryWeapon=true;
    p->room = currentRoom;
}

void Tank::shootSecondary(Projectile* p){
    secondaryReload = 0;
    energy-=sEnergy;
    if(energy<0)
        energy=0;
    p->x = x-cos((tankrot+turretrot)*PI/180)*(turretradius + barrellength);
    p->y = y-sin((tankrot+turretrot)*PI/180)*(turretradius + barrellength);
    p->angle = turretrot+tankrot;
    if(sspread>0)
        p->angle += ((rand()%1000)*1.0)/(500/(sspread)) - sspread;
	double tmp = 0.8+(rand()%401)/1000.0;
    p->xvel = xvel-cos(p->angle*PI/180)*secondaryProjectileSpeed*tmp;
    p->yvel = yvel-sin(p->angle*PI/180)*secondaryProjectileSpeed*tmp;

    p->width = sprojwidth;
    p->length = sprojlength;
    p->look = sproj;
    p->clip = &sprojclip;

    p->traileffect = &Seffect;
    p->damage = secondaryDamage;
    p->range = secondaryRange*(0.8+(rand()%401)/1000.0);
    p->passesShield = sPassesShield;

    p->ownerID=ID;
    p->primaryWeapon=false;
    p->room=currentRoom;
}

Tank::Tank(){};

Tank::Tank(std::string nname, double xpos, double ypos, double rot, uint16_t room){
    stuckness=0;
    if(nname==""){
        nname="unnamed";
    }
	positionReset(nname, xpos, ypos, rot, room, true);
}

void Tank::positionReset(std::string nname, double xpos, double ypos, double rot, uint16_t room, bool reset){
	if(nname!="")
        name = nname;
	if(xpos>=0)
        x = xpos;
	if(ypos>=0)
        y = ypos;
	if(rot>=0)
        tankrot = rot;
    if(reset){
        turretrot = 0;
        xvel = 0;
        yvel = 0;
        vel = 0;
	}
	currentRoom = room;
}

Tank::~Tank(){
	//free();
}

void Tank::setOther(int nID, double npower, double nbrakeforce, double nmaxvel, double nmass, double nmaxEnergy, double nenergyGen, uint32_t exp, uint32_t materials){
	if( npower > 0 )
		power = npower;
	if( nbrakeforce > 0 )
		brakeforce = nbrakeforce;
	if( nmaxvel > 0 )
        maxvel = nmaxvel;
    if( nmass > 0)
        mass = nmass;
    if( nmaxEnergy > 0)
        maxEnergy = nmaxEnergy;
    energy = maxEnergy;
    if( nenergyGen > 0)
        energyGen = nenergyGen;
    ID=nID;
    if(exp>0)
		expgiven=exp;
	if(materials>0)
		materialsgiven=materials;
}

void Tank::setWeapons(double nPdamage, double nSdamage, double nPprojectileSpeed, double nSprojectileSpeed, int nprimaryROF, int nsecondaryROF, double npspread, double nsspread, int npburst, int nsburst, ParticleLine nPeffect, ParticleLine nSeffect, bool npPassesShield, bool nsPassesShield, double npEnergy, double nsEnergy){
    if( nPprojectileSpeed > 0 )
        primaryProjectileSpeed = nPprojectileSpeed;
    if( nSprojectileSpeed > 0 )
        secondaryProjectileSpeed = nSprojectileSpeed;
    if( nprimaryROF > 0 )
        primaryROF = nprimaryROF;
    if( nsecondaryROF > 0 )
        secondaryROF = nsecondaryROF;
    primaryReload = primaryROF;
    secondaryReload = secondaryROF;
    pspread = npspread;
    sspread = nsspread;
    if( npburst > 0)
        pburst = npburst;
    if( nsburst > 0)
        sburst = nsburst;
    Peffect = nPeffect;
    Seffect = nSeffect;
    primaryDamage=nPdamage;
    secondaryDamage=nSdamage;
    pPassesShield=npPassesShield;
    sPassesShield=nsPassesShield;
    pEnergy=npEnergy;
    sEnergy=nsEnergy;
}

void Tank::setDimensions(double nlength, double nwidth, double nturretradius, double nbarrellength, double nbarrelwidth, double npprojlength, double npprojwidth, double nsprojlength, double nsprojwidth){
	if( nlength != 0 )
		length = nlength*mul;
	if( nwidth != 0 )
		width = nwidth*mul;
	if( nturretradius != 0 )
		turretradius = nturretradius*mul;
	if( nbarrellength != 0 )
		barrellength = nbarrellength*mul;
	if( nbarrelwidth != 0 )
		barrelwidth = nbarrelwidth*mul;
    if( npprojlength != 0 )
        pprojlength = npprojlength*mul;
    if( npprojwidth != 0 )
        pprojwidth = npprojwidth*mul;
    if( nsprojlength != 0 )
        sprojlength = nsprojlength*mul;
    if( nsprojwidth != 0 )
        sprojwidth = nsprojwidth*mul;
}

void Tank::setHealth(double nmaxHealth, double nmaxShield, double nshieldRegen, int nshieldDelay){
    maxHealth=nmaxHealth;
    maxShield=nmaxShield;
    shieldRegen=nshieldRegen;
    shieldDelay=nshieldDelay;
    health=maxHealth;
    shield=maxShield;
}

void Tank::free(){
    //Causes segfaults
	if(body!=NULL){
		SDL_DestroyTexture(body);
	}
	if(turret!=NULL){
		SDL_DestroyTexture(turret);
	}
	if(barrel!=NULL){
		SDL_DestroyTexture(barrel);
    }
    if(pproj!=NULL){
        SDL_DestroyTexture(pproj);
    }
    if(sproj!=NULL){
        SDL_DestroyTexture(sproj);
    }
}

void Tank::loadLook0(){
    loadLook("data/graphics/body.png", "data/graphics/turret.png", "data/graphics/barrel.png", "data/graphics/primaryprojectile.png", "data/graphics/secondaryprojectile.png", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
}

void Tank::loadLook(std::string bodypath = "data/graphics/body.png", std::string turretpath = "data/graphics/turret.png", std::string barrelpath = "data/graphics/barrel.png", std::string pprojpath = "data/graphics/projectile.png", std::string sprojpath = "data/graphics/secondaryprojectile.png", PercentRect* bodysource = NULL, PercentRect* turretsource = NULL, PercentRect* barrelsource = NULL, PercentRect* pprojsource = NULL, PercentRect* sprojsource = NULL, SDL_Rect* bodystretchn = NULL, SDL_Rect* turretstretchn = NULL, SDL_Rect* barrelstretchn = NULL, SDL_Rect* pprojstretchn = NULL, SDL_Rect* sprojstretchn = NULL){
	//free();

	SDL_Surface* bodyimage = IMG_Load( bodypath.c_str() );						//Load images
	SDL_Surface* turretimage = IMG_Load( turretpath.c_str() );
	SDL_Surface* barrelimage = IMG_Load( barrelpath.c_str() );
	SDL_Surface* pprojimage = IMG_Load( pprojpath.c_str() );
	SDL_Surface* sprojimage = IMG_Load( sprojpath.c_str() );

	SDL_SetColorKey( bodyimage, SDL_TRUE, SDL_MapRGB( bodyimage->format, 0xFF, 0xFF, 0xFF ) );	//Colour key loaded images
	SDL_SetColorKey( turretimage, SDL_TRUE, SDL_MapRGB( turretimage->format, 0xFF, 0xFF, 0xFF ) );
	SDL_SetColorKey( barrelimage, SDL_TRUE, SDL_MapRGB( barrelimage->format, 0xFF, 0xFF, 0xFF ) );
	SDL_SetColorKey( pprojimage, SDL_TRUE, SDL_MapRGB( pprojimage->format, 0xFF, 0xFF, 0xFF ) );
	SDL_SetColorKey( sprojimage, SDL_TRUE, SDL_MapRGB( sprojimage->format, 0xFF, 0xFF, 0xFF ) );

	body = SDL_CreateTextureFromSurface( gRenderer, bodyimage );					//Create texture
	turret = SDL_CreateTextureFromSurface( gRenderer, turretimage );
	barrel = SDL_CreateTextureFromSurface( gRenderer, barrelimage );
	pproj = SDL_CreateTextureFromSurface( gRenderer, pprojimage );
	sproj = SDL_CreateTextureFromSurface( gRenderer, sprojimage );

	if( bodysource == NULL ){									//Prepare rectangles for clipping textures
		SDL_Rect temp = {0, 0, bodyimage->w, bodyimage->h};
		bodyclip = temp;
	}else{
		bodyclip.w = bodyimage->w * bodysource->w / 100;
		bodyclip.h = bodyimage->h * bodysource->h / 100;
		bodyclip.x = bodyimage->w * bodysource->x / 100;
		bodyclip.y = bodyimage->h * bodysource->y / 100;
	}
	if( turretsource == NULL ){
		SDL_Rect temp = {0, 0, turretimage->w, turretimage->h};
		turretclip = temp;
	}else{
		turretclip.w = turretimage->w * turretsource->w / 100;
		turretclip.h = turretimage->h * turretsource->h / 100;
		turretclip.x = turretimage->w * turretsource->x / 100;
		turretclip.y = turretimage->h * turretsource->y / 100;
	}
	if( barrelsource == NULL ){
		SDL_Rect temp = {0, 0, barrelimage->w, barrelimage->h};
		barrelclip = temp;
	}else{
		barrelclip.w = barrelimage->w * barrelsource->w / 100;
		barrelclip.h = barrelimage->h * barrelsource->h / 100;
		barrelclip.x = barrelimage->w * barrelsource->x / 100;
		barrelclip.y = barrelimage->h * barrelsource->y / 100;
	}
	if( pprojsource == NULL ){
		SDL_Rect temp = {0, 0, pprojimage->w, pprojimage->h};
		pprojclip = temp;
	}else{
		pprojclip.w = pprojimage->w * pprojsource->w / 100;
		pprojclip.h = pprojimage->h * pprojsource->h / 100;
		pprojclip.x = pprojimage->w * pprojsource->x / 100;
		pprojclip.y = pprojimage->h * pprojsource->y / 100;
	}

	if( sprojsource == NULL ){
		SDL_Rect temp = {0, 0, sprojimage->w, sprojimage->h};
		sprojclip = temp;
	}else{
		sprojclip.w = sprojimage->w * sprojsource->w / 100;
		sprojclip.h = sprojimage->h * sprojsource->h / 100;
		sprojclip.x = sprojimage->w * sprojsource->x / 100;
		sprojclip.y = sprojimage->h * sprojsource->y / 100;
	}

	SDL_FreeSurface( bodyimage );									//Free surfaces
	SDL_FreeSurface( turretimage );
	SDL_FreeSurface( barrelimage );
	SDL_FreeSurface( pprojimage );
	SDL_FreeSurface( sprojimage );
}

void Tank::render(){											//Render tank at current position with set dimentions
	SDL_Rect temp = {xToDispX(x-width/2), yToDispY(y-length/2), width*xzoom, length*yzoom};						//x-width/2 is used, so that the x and y coordinates refer to the center of the tank
	SDL_RenderCopyEx( gRenderer, body, &bodyclip, &temp, tankrot+90, NULL, SDL_FLIP_NONE);

	temp = {xToDispX(x-turretradius), yToDispY(y-turretradius), turretradius*2*xzoom, turretradius*2*yzoom};
	SDL_RenderCopyEx( gRenderer, turret, &turretclip, &temp, tankrot+turretrot+90, NULL, SDL_FLIP_NONE);

	SDL_Point center = {barrelwidth*xzoom/2, 0-turretradius*yzoom};
	temp = {xToDispX(x-barrelwidth/2), yToDispY(y+turretradius), barrelwidth*xzoom, barrellength*yzoom};
	SDL_RenderCopyEx( gRenderer, barrel, &barrelclip, &temp, tankrot+turretrot+90, &center, SDL_FLIP_NONE);
}

uint32_t Tank::takeDamage(double damage, bool shieldpass){
    if(index!=0 && !dead){
		boostedViewDistance=viewDistance*1000;
		if(heatnum<(255-500*stepSize))
			heatnum+=500*stepSize;
		else
			heatnum=255;
    }
	if(!shieldpass){
            shieldCount=0;
        if(shield>damage)
            shield-=damage;
        else{
            damage-=shield;
            shield=0;
            if(health>damage)
                health-=damage;
            else{
                if(dead){
//					health=0;
					return 0;
                }else if(index==0){
					character.materials=0;
                }
				primaryReload=0;
				secondaryReload=0;
                energy=0;
                dead=true;
                if(index!=0)
					health=0;
				else if(character.repairs>0){
					health=0;
					character.repairs--;
				}else{
					health=-1;
				}
                return expgiven;
            }    //call death animation
        }
    }else{
        if(health>damage)
            health-=damage;
        else{
            if(dead){
				health=0;
				shield=0;
				return 0;
			}else if(index==0){
				character.materials=0;
			}
			primaryReload=0;
			secondaryReload=0;\
			shieldCount=0;
			energy=0;
            dead=true;
            if(index!=0)
				health=0;
			else if(character.repairs>0){
				health=0;
				character.repairs--;
			}else{
				health=-1;
			}
			shield=0;
            return expgiven;
        }    //call death animation
    }
    return 0;
}

void Tank::load(std::ifstream* file){
	std::string line;
	getline(*file,line);
	x=atof(line.c_str());
	getline(*file,line);
	y=atof(line.c_str());
	getline(*file,line);
	stuckness=atoi(line.c_str());
	getline(*file,line);
	xvel=atof(line.c_str());
	getline(*file,line);
	yvel=atof(line.c_str());
	getline(*file,line);
	vel=atof(line.c_str());
	getline(*file,line);
	tankrot=atof(line.c_str());
	getline(*file,line);
	turretrot=atof(line.c_str());
	getline(*file,line);
	targetX=atof(line.c_str());
	getline(*file,line);
	targetY=atof(line.c_str());
	getline(*file,line);
	targetvel=atof(line.c_str());
	getline(*file,line);
	energy=atof(line.c_str());
	getline(*file,line);
	primaryReload=atof(line.c_str());
	getline(*file,line);
	secondaryReload=atof(line.c_str());
	getline(*file,line);
	health=atof(line.c_str());
	getline(*file,line);
	shield=atof(line.c_str());
	getline(*file,line);
	shieldCount=atof(line.c_str());
	getline(*file,line);
	if(line.compare("t")==0)
		dead=true;
	else
		dead=false;
	getline(*file,line);
	if(line.compare("t")==0)
		stripped=true;
	else
		stripped=false;
	getline(*file,line);
	index=atoi(line.c_str());
	getline(*file,line);
	currentRoom=atoi(line.c_str());
}

void Tank::save(std::ofstream* file){
    std::ostringstream strs;
    strs << x << "\n";
    strs << y << "\n";
    strs << stuckness << "\n";
    strs << xvel << "\n";
    strs << yvel << "\n";
    strs << vel << "\n";
    strs << tankrot << "\n";
    strs << turretrot << "\n";
    strs << targetX << "\n";
    strs << targetY << "\n";
    strs << targetvel << "\n";
    strs << energy << "\n";
    strs << primaryReload << "\n";
    strs << secondaryReload << "\n";
    strs << health << "\n";
    strs << shield << "\n";
    strs << shieldCount << "\n";
    if(dead)
        strs << "t\n";
    else
        strs << "f\n";
	if(stripped)
		strs << "t\n";
	else
		strs << "f\n";
    strs << index << "\n";
    strs << currentRoom << "\n";
    *file << strs.str();
}

void Tank::loadfromcharacter(){
	double mul=1;
	for(int i=0;i<character.brakeup;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	brakeforce=character.brake*mul;
	mul=1;
	for(int i=0;i<character.delayup;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	shieldDelay=character.delay/mul;
	mul=1;
	for(int i=0;i<character.energyup;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	maxEnergy=character.energy*mul;
	mul=1;
	for(int i=0;i<character.generationup;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	energyGen=character.generation*mul;
	mul=1;
	for(int i=0;i<character.healthup;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	maxHealth=character.health*mul;
	mul=1;
	for(int i=0;i<character.massdown;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	mass=character.mass/mul;
	mul=1;
	for(int i=0;i<character.maxVelocityup;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	maxvel=character.maxVelocity*mul;
	name=character.name;
	mul=1;
	for(int i=0;i<character.powerup;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	power=character.power*mul;
	mul=1;
	for(int i=0;i<character.regenup;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	shieldRegen=character.regen*mul;
	mul=1;
	for(int i=0;i<character.shieldup;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	maxShield=character.shield*mul;
	//Accuracy(spread), Burst(int), damage, energy, Id(int), Name, Passesshield(flag), 1primary(flag), Rof(int), Gspeed, Another(start next one)
	Weapon primary;
	Weapon secondary;
	for(int i=0;i<weapons.size();i++){
		if(weapons[i].ID==character.primaryID)
			primary=weapons[i];
		if(weapons[i].ID==character.secondaryID)
			secondary=weapons[i];
	}
	WeaponUpgrades prim;
	WeaponUpgrades second;
	for(int i=0;i<character.weaponUpgrades.size();i++){
		if(character.weaponUpgrades[i].ID==character.primaryID)
			prim=character.weaponUpgrades[i];
		if(character.weaponUpgrades[i].ID==character.secondaryID)
			second=character.weaponUpgrades[i];
	}
	mul=1;
	for(int i=0;i<prim.range;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	primaryRange=primary.range*mul;
	mul=1;
	for(int i=0;i<second.range;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	secondaryRange=secondary.range*mul;
	mul=1;
	mul=1;
	for(int i=0;i<prim.spread;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	pspread=primary.spread/mul;
	mul=1;
	for(int i=0;i<second.spread;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	sspread=secondary.spread/mul;
	mul=1;
	for(int i=0;i<prim.burst;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	pburst=primary.burst*floor(mul);
	mul=1;
	for(int i=0;i<second.burst;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	sburst=secondary.burst*floor(mul);
	mul=1;
	for(int i=0;i<prim.damage;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	primaryDamage=primary.damage*mul;
	mul=1;
	for(int i=0;i<second.damage;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	secondaryDamage=secondary.damage*mul;
	mul=1;
	for(int i=0;i<prim.energy;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	pEnergy=primary.energy/mul;
	mul=1;
	for(int i=0;i<second.energy;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	sEnergy=secondary.energy/mul;
	pPassesShield=primary.passesshields;
	sPassesShield=secondary.passesshields;
	mul=1;
	for(int i=0;i<prim.ROF;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	primaryROF=primary.ROF/mul;
	mul=1;
	for(int i=0;i<second.ROF;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	secondaryROF=secondary.ROF/mul;
	mul=1;
	for(int i=0;i<prim.speed;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	primaryProjectileSpeed=primary.speed*mul;
	mul=1;
	for(int i=0;i<second.speed;i++){
		mul*=pow(firstup, pow(deterioration, (i-1)));
	}
	secondaryProjectileSpeed=secondary.speed*mul;
	health=maxHealth;
	energy=maxEnergy;
	shield=maxShield;
}

void Tank::broadcast(){
	for(int i=1;i<tanks.size();i++){
		if(i!=index && sqrt(pow(tanks[i]->getX()-x, 2)+pow(tanks[i]->getY()-y, 2))<broadcastDistance){
			tanks[i]->pointTo(targetX, targetY);
			tanks[i]->resetTimeSinceSeen();
		}
	}
}


//{those methods

void Tank::resetTimeSinceSeen(){
	timeSinceSeen=0;
    patrolling=false;
}
void Tank::incrementTimeSinceSeen(double increment){
	timeSinceSeen+=increment;
}

double Tank::getShieldTimer(){
	return shieldDelay-shieldCount;
}

double Tank::getShieldDelay(){
	return shieldDelay;
}

void Tank::boostView(){
	boostedViewDistance=1000*viewDistance;
}

double Tank::getViewDistance(bool reset){
	double tmp=boostedViewDistance;
	if(reset)
		boostedViewDistance=viewDistance;
	return tmp;
}

bool Tank::isStripped(){
	return stripped;
}

void Tank::strip(){
	stripped=true;
}

uint32_t Tank::getmaterials(){
	return materialsgiven;
}

uint32_t Tank::getexp(){
	return expgiven;
}

int Tank::getCurrentRoom(){
	return currentRoom;
}

void Tank::getProjectileLook(SDL_Texture** look, SDL_Rect** clip, ParticleLine** traileffect, bool primary){
    if(primary){
        *look = pproj;
        *clip = &pprojclip;
        *traileffect = &Peffect;
    }else{
        *look = sproj;
        *clip = &sprojclip;
        *traileffect = &Seffect;
    }
}

int Tank::getID(){
    return ID;
}

double Tank::getPEnergy(){
    return pEnergy;
}

double Tank::getSEnergy(){
    return sEnergy;
}

double Tank::getEnergyGen(){
    return energyGen;
}

double Tank::getEnergy(){
    return energy;
}

double Tank::getMaxEnergy(){
    return maxEnergy;
}

bool Tank::getpPassesShield(){
    return pPassesShield;
}

bool Tank::getsPassesShield(){
    return sPassesShield;
}

double Tank::getMaxVel(){
    return maxvel;
}

double Tank::getAcceleration(){
    return power/mass;
}

double Tank::getPspread(){
    return pspread;
}

double Tank::getSspread(){
    return sspread;
}

double Tank::getPrimaryDamage(){
    return primaryDamage;
}
double Tank::getSecondaryDamage(){
    return secondaryDamage;
}

double Tank::getShieldRegen(){
    return shieldRegen;
}

int Tank::getPrimaryROF(){     //reload time in game steps
    return primaryROF;
}
int Tank::getSecondaryROF(){
    return secondaryROF;
}
double Tank::getPrimaryReload(){  //time spent reloading
    return primaryReload;
}
double Tank::getSecondaryReload(){
    return secondaryReload;
}

double Tank::getLength(){
    return length;
}

bool Tank::isDead(){
    return dead;
}

double Tank::getHealth(){
    return health;
}
double Tank::getMaxHealth(){
    return maxHealth;
}
double Tank::getShield(){
    return shield;
}
double Tank::getMaxShield(){
    return maxShield;
}

void Tank::getTarget(double** x, double** y){
	*x=&targetX;
	*y=&targetY;
}

bool Tank::hasseentarget(){
	if(tanks[0]->isDead() || timeSinceSeen>=chaseTime){
		//targetX=-1000;
		//targetY=-1000;
		timeSinceSeen=chaseTime;
		patrolling=true;
		return false;
	}
    patrolling = !(targetX!=-1000 || targetY!=-1000);
    return !patrolling;
}

void Tank::settargetvel(double n){
    targetvel = n;
}

double Tank::getVel(){
    return vel;
}

int Tank::getIndex(){
    return index;
}

void Tank::setIndex(int i){
    index = i;
}

std::string Tank::getName(){
    return name;
}

void Tank::setName(std::string nname){
    name = nname;
}

void Tank::setIsCircle(bool n){
    iscircle = n;
}

bool Tank::isACircle(void){
    return iscircle;
}

Shape Tank::getShape(){
    Shape temp;
    std::vector<double> xvec;
    std::vector<double> yvec;
    if(!iscircle){
		double tankrotrad = tankrot * PI / 180;
		xvec.push_back(x+cos(tankrotrad)*length/2+sin(tankrotrad)*width/2);    //front left
		yvec.push_back(y+sin(tankrotrad)*length/2-cos(tankrotrad)*width/2);
		xvec.push_back(x+cos(tankrotrad)*length/2-sin(tankrotrad)*width/2);    //front right
		yvec.push_back(y+sin(tankrotrad)*length/2+cos(tankrotrad)*width/2);
		xvec.push_back(x-cos(tankrotrad)*length/2+sin(tankrotrad)*width/2);    //back left
		yvec.push_back(y-sin(tankrotrad)*length/2-cos(tankrotrad)*width/2);
		xvec.push_back(x-cos(tankrotrad)*length/2-sin(tankrotrad)*width/2);    //back right
		yvec.push_back(y-sin(tankrotrad)*length/2+cos(tankrotrad)*width/2);
    }else{
		std::cout << "x: " << x << " y: " << y << "\n";
		for(double i = 0; i<1; i+=1.0/circleres){
			xvec.push_back(x + cos(2*PI*i)*length/2);
			yvec.push_back(y + sin(2*PI*i)*length/2);
		}
    }
    sortpoints(&xvec, &yvec);
    temp.x = xvec;
    temp.y = yvec;
    shape.room=currentRoom;
    return temp;
}

int Tank::getPburst(){
    return pburst;
}

int Tank::getSburst(){
    return sburst;
}

double Tank::getX(){
//	std::cout << "X " << x << "\n";
	return x;
}


